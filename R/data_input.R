#' Read data from a CosmoSIS format linearized matrix sample file,
#' e.g. a power spectrum file.
#' @param dirname The name of the directory from which we read.
#' @param filename The name of the file we will read.
#' @param quiet  Passed to \code{base::scan}.
#' @return The vector of values.
cosmo.scan <- function(dirname, filename, quiet=TRUE)
{
  scan(file.path(dirname, filename), comment.char = "#", quiet = quiet)
}

#' Create a CosmoSIS 'theory' dataframe from all the named files.
#'
#'
#' Create a CosmoSIS 'theory' dataframe from the 'theory' files
#' generated by a run of CosmoSIS. It is assumed that each file contains
#' a single column of data, and that all the columns are of the same
#' length. This is the standard CosmoSIS output format for a variety of
#' theory calculations. Lines beginning with CosmoSIS comment character
#' "#" are ignored. The names of the columns are determined from the
#' names of the files, by dropping the file extension.
#'
#' @export
#' @param fnames A character vector containing the names of the files to be read.
#' @return A CosmoSIS 'theory' dataframe.
#
# If we change the output of CosmoSIS to make a single file with
# multiple columns, then read.table() would work directly and probably a
# bit more efficiently.
make.theory.dataframe <- function(fnames)
{
  # Scan each file, creating a vector of the right name
  columns <- lapply(fnames, function(n) scan(n, comment.char = "#", quiet = TRUE))
  result <- data.frame(columns)
  names(result) <- lapply(fnames, function(n) tools::file_path_sans_ext(basename(n)))
  result
}

#' Create a CosmoSIS matter power dataframe from all the named files.
#'
#' It is assumed the file format is the CosmoSIS format for storing power
#' spectra. Note this format is different from the format used for the storage
#' of scalar parameters.
#' @export
#' @param dirname The name of the directory containing the CosmoSIS power
#'   spectrum output.
#' @param type Any value; this value is replicated to fill the \code{type}
#'   column of the dataframe.
#' @return A CosmoSIS matter power dataframe. If the directory does not exist,
#'   the returned dataframe will be empty.
make.matterpower.dataframe <- function(dirname, type)
{
  # If the directory does not exist, return an empty dataframe.
  if (!file.exists(dirname)) return(data.frame())

  # Scan each file, creating a vector of the right name
  # bind the columns into a dataframe.

  z <- cosmo.scan(dirname, "z.txt")
  k_h <- cosmo.scan(dirname, "k_h.txt")
  p_k <- cosmo.scan(dirname, "p_k.txt")
  nkh <- length(k_h)

  # The p_k array carries the data for a matrix, with 'z' varying slowly
  # and 'k_h' varying rapidly. Thus to build the dataframe, we can rely
  # on the recycling rule to get k_h correct, but have to construct z
  # ourselves.
  dframe <- data.frame(p_k = p_k,
                       k_h = k_h,
                       z = rep(z, each = nkh))
  dframe$type = type
  dframe
}

#' Extract the parameter names from a CosmoSIS sampler output file.
#'
#' The format of the first line of CosmoSIS grid and MCMC sample output carries
#' the names of the parameters that were varied in that run of CosmoSIS. This
#' function parses that line and returns the names of the parameters.
#'
#' @param txt The text to be parsed.
#' @return A character vector containing the names of the parameters read from
#'   the file.
parse.cosmosis.parameters <- function(txt) {
  tmp <- sub("#", "", txt)           # Remove comment
  parts <- stringr::str_split(tmp, "\t")[[1]]    # split on tabs
  cols <- sub("[a-zA-Z_]+--", "", parts) # remove leading section names
  sub("(like)|(post)", "loglike", cols, fixed = FALSE)
}

#' Create a data frame from CosmoSIS MCMC sampler output.
#'
#' Reads a file in CosmoSIS MCMC sampler output format and creates a data frame
#' from it. Each line in the file corresponds to a sample in the data frame;
#' each column in the file corresponds to a column in the data frame.
#'
#'
#' The columns in a CosmoSIS MCMC data frame are:
#' \describe{
#' \item{loglike}{log-likelihood of the sample.}
#'  \item{like}{normalized likelihood of the sample.}
#'  \item{\emph{others}}{one column per sampled variable in the MCMC
#'   output, named as in the output.}
#' }
#'
#' We expect the first line of the output to contain the names of the
#' parameters, separated by spaces, and with section names separated from
#' parameter names by a double-hyphen.
#'
#' @export
#' @param fname The name of the CosmoSIS MCMC sampler output file to be read.
#'   making the data frame
#' @param burn The length of the burn-in period; these samples are ignored in
#'   making the data frame.
#' @return a CosmoSIS MCMC data frame
read.cosmosis.mcmc <- function(fname, burn = 0)
{
  checkmate::assert_count(burn)
  d <- utils::read.table(fname, as.is = TRUE)
  if (burn>0) d <- d[-c(1:burn),]
  first <- readLines(fname, n = 1)
  names(d) <- parse.cosmosis.parameters(first)
  d <- append.likelihoods(d)
  tibble::as_tibble(d)
}

#' emcee.read
#'
#' @param fname The name of the CosmoSIS MCMC sampler output file to be read.
#'   making the data frame
#' @param num.walkers The number of walkers used.
#'
#' @return a CosmoSIS MCMC dataframe
#' @export
#'
emcee.read <- function(fname)
{
  num.walkers <- emcee.count.walkers(readLines(fname, 100))
  x <- read.cosmosis.mcmc(fname)
  x$walker = 1 : num.walkers
  nsamples <- nrow(x)/num.walkers
  x$n <- rep(1:(nsamples), each = num.walkers)
  x
}

#' Read a CosmoSIS grid sampler output file.
#'
#' Reads a file in CosmoSIS grid sampler output format and returns a list
#' describing the data.
#' @export
#' @param fname The name of the CosmoSIS MCMC sampler output file to be read.
#' @return A list of \code{n+1} components, where \code{n} is the number of
#'   coordinate axes comprising the grid.
#'
#'   \describe{ \item{\code{x}, \code{y}}{The \code{x} and \code{y} coordinates
#'   of the grid points, vectors of length \code{m} and \code{n}.}
#'   \item{\code{z}}{An \code{m} by \code{n} matrix of log-likelihoods.} }
read.cosmosis.grid <- function(fname)
{
  d <- utils::read.table(fname)
  first <- readLines(fname, n = 1)
  names(d) <- parse.cosmosis.parameters(first)
  d <- append.likelihoods(d)
  cols2vmat(d)
}

#' emcee.count.walkers Return the number of walkers used for this EMCEE run.
#'
#' @param txt Starting lines from the EMCEE output file
#'
#' @return The number of walkers
#' @export
#'
emcee.count.walkers <- function(txt) {
  matches <- stats::na.omit(stringr::str_match(txt, "^#walkers=(\\d+)$")[,2])
  stopifnot(length(matches) == 1)
  as.integer(matches)
}
