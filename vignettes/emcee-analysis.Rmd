---
title: "Analysis of Emcee CosmoSIS output"
author: "Marc Paterno"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Analysis of Emcee CosmoSIS output}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(rcosmosis)
```

## Emcee analysis

The function `read.emcee` is the way to read the CosmoSIS output
generated by the Emcee sampler.
The data frame contains a column for each parameter being varied by the sampler,
and also containing a column `walker`, which indicates the identify of the walker that generated
the sample,
and a column `sample`, which indicates a sample number within the series from that walker.

```{r}
root <- rprojroot::is_r_package
samples <- read.emcee(root$find_file("inst/extdata/chain_emcee_1024.txt.xz"))
head(samples) %>% knitr::kable()
```

```{r}
nwalkers            <- max(samples$walker)
nsamples_per_walker <- max(samples$sample)
nsamples            <- nrow(samples)
```

We have `r nwalkers` walkers, each with
`r nsamples_per_walker` samples,
for a total of `r nsamples` samples.

## Has the chain converged?

```{r}
nburn <- 300
```


The series of samples takes some time to achieve convergence; this period is often called the *burn-in* period.
One way to evaluate convergence of the series is to look at how it
progresses as a function of sample number;
this is often called a *trace*.
Will will do this for only a few of the walkers because using the full set makes the plots too cluttered.
We note that the walkers are *not* independent, so care is necessary in interpreting the results.

One thing we want is see is *mixing*. It is important that the different walkers
do not produce traces that stay separated; they should "forget" their initial
values, and produce traces that eventually are well-mixed.

Since there are too many walkers to visualize this, we look only at the first 8 walkers:


```{r}
filter(samples, walker %in% 1:8) %>%
  ggplot(aes(sample, omega_m, color = factor(walker))) +
  geom_point(show.legend = FALSE) +
  geom_path(show.legend = FALSE)
```

```{r}
filter(samples, walker %in% 1:4) %>%
  ggplot(aes(sample, sigma8_input, color = factor(walker))) +
  geom_point(show.legend = FALSE) +
  geom_path(show.legend = FALSE)
```

```{r}
filter(samples, walker %in% 1:4) %>%
  ggplot(aes(sample, concentration, color = factor(walker))) +
  geom_point(show.legend = FALSE) +
  geom_path(show.legend = FALSE)
```

```{r}
x <-
  samples %>%
  pivot_longer(-c(sample,walker), names_to = "param", values_to = "val")
```

We can also look at how the marginal density for each parameter converges as we go through
fixed-size batches of samples. We'll group the data by 20-sample batches (for each walker).
As above, we need to re-organize the `samples` dataframe, but this time we don't thin out the samples,
and we also assign samples to batches.

```{r}
b <- samples %>%
  mutate(batch = sample %/% 20) %>%
  pivot_longer(-c(sample, walker, batch), names_to = "param", values_to = "val")
```


## Posterior densities

For all our analysis of posterior distributions, we'll drop the first `r nburn` elements of each chain.

### 1-d marginal densities

We use a combined histogram and kernel density plot to show the 1-d marginal distributions.

```{r}
x %>%
  filter(sample > nburn) %>%
  ggplot(aes(val)) +
  geom_histogram(aes(y = ..density..), bins = 50) + 
  geom_density(color = "red") +
  facet_wrap(vars(param), scales = "free", ncol = 1)
```

The posterior for `concentration` has a long high-end tail, and so a log scale in *x* can be useful.
```{r}
x %>%
  filter(param == "concentration", sample > nburn) %>%
  ggplot(aes(val)) +
  geom_histogram(aes(y = ..density..), bins = 50) +
  geom_density(color = "red") +
  xlab("concentration") +
  scale_x_log10()
```


### 2-d marginal densities

We are using *hexbin* plots to show 2-d posterior densities because this
produces few, and easy to understand, artifacts in the plotting.
We use a log scale for the density because of wide range of density.
We also plot the contours produced by a 2D kernel density estimator,
for comparison with the hexbin results.

```{r}
samples %>%
  filter(sample > nburn) %>%
  plot_density_2d(omega_m, sigma8_input)
```

```{r}
samples %>%
  filter(sample > nburn) %>%
  plot_density_2d(omega_m, concentration, scale_y = scale_y_log10)
```

```{r}
samples %>%
  filter(sample > nburn) %>%
  plot_density_2d(sigma8_input, concentration, scale_y = scale_y_log10)
```

### Statistical summaries

```{r}
samples %>%
  select(-c(walker, sample)) %>%
  pivot_longer(everything(), names_to = "param", values_to = "val") %>%
  group_by(param) %>%
  summarize(mean = mean(val),
            median = median(val),
            sd = sd(val),
            mad = mad(val),
            "5%" = quantile(val, 0.05),
            "95%" = quantile(val, 0.95)) %>%
  knitr::kable()
```

