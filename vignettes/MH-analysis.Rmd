---
title: "Analysis of Metropolis-Hastings CosmoSIS output"
author: "Marc Paterno"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Analysis of Metropolis-Hastings CosmoSIS output}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(gganimate)
library(rcosmosis)
library(gifski)
library(gridExtra)
```

# Reading data

The function `read.metropolis.hastings` is the way to read the CosmoSIS output
generated by the Metropolis-Hastings sampler.
Because the MH sampler can run multiple chains, each of which results in a separate file,
it will be common to specify a _file glob_ to identify the set of files that are to be
read.
The result is a single data frame (more specifically, a _tibble_) containing
one row for each sample.
The data frame contains a column for each parameter being varied by the sampler,
and also containing a column `chain`, which indicates the identify of the chain that generated
the sample,
and a column `sample`, which indicates a sample number within that chain.

```{r read-mh}
samples <- read.metropolis.hastings(here::here("inst/extdata/metropolis-hastings/chain_metro_*.txt.xz"))
head(samples) %>% knitr::kable()
```

```{r include = FALSE}
nchains <- max(samples$chain)
nsamples.per.chain <- max(samples$sample)
nsamples.total <- nrow(samples)
```

We have `r nchains` chains, each with `r nsamples.per.chain` samples,
for a total of `r nsamples.total` samples.

# The burn-in period

To study the burn-in period, we'll be looking only at the first several values in each chain.

```{r include = FALSE}
nanim = 300
```

First we look at scatterplots of the first `r nanim` samples from each chain.
Each plot shows a different pair of variables.
Each point corresponds to one sample. The color of the point indicated which of the `r nchains` chains was sampled.
Note that the palette of colors is limited, so the same color is used for many different chains.
Each step in the animation correponds to a new sample. 

These plots don't provide a good idea of the path each chain takes
from sample to sample.
We can show this by animating the plots,
with one animation frame for each sample number.

```{r p1a-anim}
samples %>%
  filter(sample < nanim) %>%
  ggplot(aes(omega_m, sigma8_input, color = factor(chain))) +
  geom_point(show.legend = FALSE) +
  transition_time(sample) +
  labs(title = "Sample: {frame_time}")
```

```{r p1b-anim}
samples %>%
  filter(sample < nanim) %>%
  ggplot(aes(omega_m, concentration, color = factor(chain))) +
  geom_point(show.legend = FALSE) +
  transition_time(sample) +
  labs(title = "Sample: {frame_time}")  
```

```{r p1c-anim}
samples %>%
  filter(sample < nanim) %>%
  ggplot(aes(sigma8_input, concentration, color = factor(chain))) +
  geom_point(show.legend = FALSE) +
  transition_time(sample) +
  labs(title = "Sample: {frame_time}")
```

# Have the chains converged?

One way to evaluate convergence of the chains is to look at how they
progress as a function of sample number;
this is often called a *trace* for the chain. We will do this for the
first 3000 values from each chain.

One thing we want is see is *mixing*. It is important that the different chains
do not produce traces that stay separated; they should "forget" their initial
values, and produce traces that eventually are well-mixed.

Since there are too many chains to visualize this, we look only at the first 8
chains. We also sample the chains sparsely, showing only 1 sample in 50:

```{r q1}
q1 <-
  samples %>%
  filter(sample < 3000, sample %% 50 == 0, chain %in% 1:8) %>%
  ggplot(aes(sample, omega_m, color = factor(chain))) +
  geom_point(show.legend = FALSE) +
  geom_path(show.legend = FALSE)
```

```{r q2}
q2 <-
  samples %>%
  filter(sample < 3000, sample %% 50 == 0, chain %in% 1:4) %>%
  ggplot(aes(sample, sigma8_input, color = factor(chain))) +
  geom_point(show.legend = FALSE) +
  geom_path(show.legend = FALSE)
```

```{r q3}
q3 <-
  samples %>%
  filter(sample < 3000, sample %% 50 == 0, chain %in% 1:4) %>%
  ggplot(aes(sample, concentration, color = factor(chain))) +
  geom_point(show.legend = FALSE) +
  geom_path(show.legend = FALSE)
```

```{r qplot}
grid.arrange(q3, q1, q2, nrow = 3)
```

We can also look at how the marginal density for each parameter converges as we go through
fixed-size batches of samples. We'll group the data by 100-sample batches (for each chain).
As above, we need to re-organize the `samples` dataframe, but this time we don't thin out the samples,
and we also assign samples to batches.

```{r batches}
b <- samples %>%
  filter(sample < 3000) %>%
  mutate(batch = sample %/% 100) %>%
  pivot_longer(-c(sample, chain, batch), names_to = "param", values_to = "val")
```

We can then histogram the posterior densities, and observe how they change from batch to batch.
```{r}
ggplot(b, aes(val)) +
  geom_histogram(aes(y = ..density..), bins = 50) + 
  geom_histogram(bins = 100) +
  facet_wrap(vars(param), scales = "free", ncol = 1) +
  transition_time(batch)
```

# Posterior densities

```{r nburn, include = FALSE}
nburn <- 3000
```

For all our analysis of posterior distributions, we'll drop the first `r nburn` elements of each chain.

## 1-d marginal densities

We use a combined histogram and kernel density plot to show the 1-d marginal distributions.

To make these plots, we first transform the data
from a form that has one row per sample _per chain_,
to one that has one row per sample _per chain per physical parameter_.
This reshaping allows us to condition the plot on the name of the physical
parameter, and thus to have a single graphic to plot.

The transformation of the data is done using `tidyr::pivot_longer`.
We select only 1 in 50 samples, to avoid overcrowding the plot.

```{r x}
x <-
  samples %>%
  filter(sample > nburn) %>%
  filter(sample %% 50 == 0) %>%
  pivot_longer(-c(sample,chain), names_to = "param", values_to = "val")
```


```{r d1}
x %>%
  ggplot(aes(val)) +
  geom_histogram(aes(y = ..density..), bins = 50) + 
  geom_density(color = "red") +
  facet_wrap(vars(param), scales = "free", ncol = 1)
```

The posterior for `concentration` has a long high-end tail, and so a log scale in *x* can be useful.
```{r dconc}
x %>%
  filter(param == "concentration") %>%
  ggplot(aes(val)) +
  geom_histogram(aes(y = ..density..), bins = 50) +
  geom_density(color = "red") +
  xlab("concentration") +
  scale_x_log10()
```

## 2-d marginal densities

We are using *hexbin* plots to show 2-d posterior densities because this
produces few, and easy to understand, artifacts in the plotting.
We use a log scale for the density because of wide range of density.
We also plot the contours produced by a 2D kernel density estimator,
for comparison with the hexbin results.

```{r d1a}

samples %>%
  filter(sample > nburn) %>%
  plot_density_2d(omega_m, sigma8_input)
```

```{r d1b}

samples %>%
  filter(sample > nburn) %>%
  plot_density_2d(omega_m, concentration, scale_y = scale_y_log10)
```

```{r d1c}

samples %>%
  filter(sample > nburn) %>%
  plot_density_2d(sigma8_input, concentration, scale_y = scale_y_log10)
```

## Statistical summaries

```{r}
samples %>%
  select(-c(chain, sample)) %>%
  pivot_longer(everything(), names_to = "param", values_to = "val") %>%
  group_by(param) %>%
  summarize(mean = mean(val),
            median = median(val),
            sd = sd(val),
            mad = mad(val),
            "5%" = quantile(val, 0.05),
            "95%" = quantile(val, 0.95)) %>%
  knitr::kable()
```

